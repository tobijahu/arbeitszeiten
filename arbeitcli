#!/bin/python3
# -*- coding: utf-8 -*-

'''
This script may be used to...
Or to process a file with a record of start and end times as well as breaks.
In a linux environment this may be called using
cat example-arbeitszeiten.csv | awk '{ $1=""; print}' | sed -e 's/,//g' \
| sed -e 's/\"Gleitzeit\"//g;s/\"Feiertag\"//g;s/\"Urlaub\"//g;s/\"Krank\"//g' \
| python arbeit-cli
'''


import sys


def eprint(*args, **kwargs):
    '''
    Print to stderr
    '''
    print(*args, file=sys.stderr, **kwargs)


try:
    import libarbeitszeiten as liba
except ImportError:
    eprint('Could not import module libarbeitszeiten. \
Check, if libarbeitszeiten.py is available in this dir.')


KONFIGURATION = {'tagesarbeitsminuten' : liba.TAGESARBEITSMINUTEN,
                 'start_gegeben' : True,
                 'konformitaetsinfo' : True,
                 'roh' : False,
                 'unkorrigiert' : False,
                 'wert_liste' : None
                }


def print_help():
    '''
    Info über die Benutzung der Command Line Interfaces (CLI)
    '''
    print("Usage: " + str(sys.argv[0]) + " -e -t 12:00 15:00 15:30")
    print("  -h, --help        diese Hilfe anzeigen und beenden")
    print("      --version     Versionsinformation anzeigen und beenden")
    print("  -e                Startzeit nicht gegeben")
    print("  -t                ")
    print("  -t=5              Gesamte Arbeitszeit des Tages in Minuten")
    print("  -o  --outlaw      Info zu nicht-gesetzeskonformen Eingaben ausgeben")
    print("  -r  --raw         Rohausgabe")
    print("  -u  --uncorrected Zeiten unkorrigiert ausgeben")
    sys.exit(1)


def option_tagesarbeitsminuten(arg):
    '''
    Auswertung der Option -t. Die Nutzung dieser Option sieht die Übergabe
    eines Wertes vor, der hier ausgewertet wird.
    '''
    if not arg.split("=")[0] == '-t':
        return None
    if len(arg.split("=")) > 1:
        if arg.split("=")[1] == '':
            eprint('Kein Minutenwert spezifiziert.')
            sys.exit(1)
        elif int(arg.split("=")[1]) < 0:
            eprint('%r ist zu klein' % arg.split("=")[1])
            sys.exit(1)
        elif int(arg.split("=")[1]) > 24*60:
            eprint('%r ist zu groß' % arg.split("=")[1])
            sys.exit(1)
        tagesarbeitsminuten = arg.split("=")[1]
        return int(tagesarbeitsminuten)
    return None


def args_auswerten(*args):
    '''
    Alle Übergabeparameter aus args auswerten und auf Richtigkeit überprüfen.
    '''
    resultat = KONFIGURATION
    wert_liste = list(args)
    for arg in args:
        tagesarbeitsminuten_kandidat = option_tagesarbeitsminuten(arg)
        if not tagesarbeitsminuten_kandidat is None:
            resultat['tagesarbeitsminuten'] = tagesarbeitsminuten_kandidat
            wert_liste.remove(arg)
            continue
        elif arg.split("=")[0] == '-e':
            resultat['start_gegeben'] = False
            wert_liste.remove(arg)
            continue
        elif arg.split("=")[0] == '-o' or arg.split("=")[0] == '--outlaw':
            resultat['konformitaetsinfo'] = False
            wert_liste.remove(arg)
            continue
        elif arg.split("=")[0] == '-r' or arg.split("=")[0] == '--raw':
            resultat['roh'] = True
            wert_liste.remove(arg)
            continue
        elif arg.split("=")[0] == '-u' or arg.split("=")[0] == '--uncorrected':
            resultat['unkorrigiert'] = True
            wert_liste.remove(arg)
            continue
        elif arg.split("=")[0] == '-h' or arg.split("=")[0] == '--help':
            print_help()
        elif liba.ist_zeitstring(arg) or liba.ist_minuten(arg):
            resultat['wert_liste'] = wert_liste
            return resultat
        else:
            eprint("Falsches Argument: %r" % arg)
            sys.exit(1)
    return None


def mini_wrapper(string, bezeichnung, wert):
    '''
    Bezeichnung, Zeitwert und Komma an übergebenen String weitergeben
    '''
    if string:
        string += ', '
    string += str(bezeichnung)
    tage, minuten = divmod(wert, 24*60)
    string += str(liba.zeitpunkt_zu_zeitstring(liba.minuten_zu_zeitpunkt(minuten)))
    if tage == 1:
        string += ' (n. T.)'
    elif tage > 0:
        string += ' (i. ' + str(tage) + ' T.)'
    return string


def resultat_wrappen(resultat, konform, unkorrigiert):
    '''
    Je nach zurückgegebenen Werten, wird das Ergebnis angezeigt.
    '''

    if len(resultat) != 6:
        raise AssertionError
    if unkorrigiert:
        diff = 0
    else:
        diff = resultat[4]
    string = ''
    if resultat[0]:
        string = mini_wrapper(string, 'Arbeitszeit: ', resultat[0])
    if resultat[1]:
        string = mini_wrapper(string, 'Startzeit: ', resultat[1] - diff)
    if resultat[2]:
        string = mini_wrapper(string, 'Endzeit: ', resultat[2] + diff)
    if (resultat[3] or resultat[3] == 0) and (resultat[1] or resultat[2]):
        string = mini_wrapper(string, 'Pausenzeit: ', resultat[3] + diff)
    else:
        string = mini_wrapper(string, 'Pausenzeit: ', resultat[3])
    print(string)
    if konform and not resultat[5]:
        if not resultat[0] and diff > 0:
            eprint('Arbeits- und/oder Pausenzeiten an gesetzliche Regelung angepasst.')
            eprint('%r Minute(n) Pause hinzugefügt.' % diff)
        elif resultat[0] and diff > 0:
            eprint('Arbeits- und/oder Pausenzeit nicht gesetzesconform')
            eprint('Zusätzliche Pause von %r Minute(n) erforderlich.' % diff)
        else:
            eprint('Arbeits- und/oder Pausenzeit nicht gesetzesconform')


def wert_liste_verarbeiten(int_liste):
    '''
    Konvertiert
    '''
    konv_uebergabe_werte = []
    for t_in_min in int_liste:
        if liba.ist_zeitstring(t_in_min):
            konv_uebergabe_werte.append(liba.zeitstring_zu_zeitpunkt(t_in_min))
        else:
            konv_uebergabe_werte.append(t_in_min)
    return konv_uebergabe_werte


def auswerten_wrapped_call(parameter):
    '''
    auswerten() erwartet als zweite Eingabe eine Liste aus integers
    und Zeitpunkten (h,m) mit Stunden h und Minuten m. Die zeitstrings
    in uebergabe[2] enthalten keine Zeitpunkte/Tupel, sondern zeit-
    strings. Deshalb muss hier zunächst konvertiert werden.
    '''
    try:
        assert isinstance(parameter, dict),\
            "%r is not a dict" % parameter
    except AssertionError:
        raise

    resultat = liba.auswerten(parameter['wert_liste'],\
                              parameter['tagesarbeitsminuten'],\
                              parameter['start_gegeben']
                             )

    if not parameter['roh']:
        resultat_wrappen(resultat, \
                         parameter['konformitaetsinfo'], \
                         parameter['unkorrigiert']\
                        )
    else:
        print(*resultat)


def keine_leeren_zeilen(eingabe_mit_leeren_zeilen):
    '''
    Leere Zeilen aus Eingabe überspringen -- nur nicht-leere Zeilen
    übergeben.
    '''
    for zeile in eingabe_mit_leeren_zeilen:
        if zeile.rstrip(): # Zeile leer?
            yield zeile


if __name__ == "__main__":
    if sys.stdin.isatty():
        if len(sys.argv) < 2:
            print_help()# Wenn stdin und uebergabe leer sind, gebe die Hilfe aus.

        parameter_dict = args_auswerten(*sys.argv[1:])

        parameter_dict['wert_liste'] = wert_liste_verarbeiten(parameter_dict['wert_liste'])
        auswerten_wrapped_call(parameter_dict)

    else:
        for nicht_leere_zeile in keine_leeren_zeilen(sys.stdin):
            try:
                parameter_dict = args_auswerten(*sys.argv[1:], *nicht_leere_zeile.split())
            except Exception:
                eprint("Fehler in Argumente-Auswertung. ")
            parameter_dict['konformitaetsinfo'] = True
            parameter_dict['roh'] = True
            parameter_dict['unkorrigiert'] = True
            try:
                parameter_dict['wert_liste'] = wert_liste_verarbeiten(parameter_dict['wert_liste'])
            except Exception:
                eprint("Fehler in Argumente-Auswertung. ")
            auswerten_wrapped_call(parameter_dict)

    sys.exit(0)
